<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TimeRunner — Sprite Build</title>
<style>
  :root{--bg:#0b1420;--panel:#081827cc;--accent:#7dd3fc}
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Arial;color:#e6eef6}
  #wrap{position:relative;height:100vh;overflow:hidden}
  canvas{display:block;width:100%;height:100%}
  #ui{
    position:absolute;left:12px;top:12px;background:var(--panel);padding:8px;border-radius:8px;font-weight:700;z-index:10;
  }
  #ui .small{font-weight:400;font-size:13px;color:#bfd7e6}
  #shopModal{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#071a26;padding:18px;border-radius:12px;display:none;
    width:720px;max-width:94vw;color:#eaf6ff;box-shadow:0 10px 40px rgba(0,0,0,0.6);max-height:84vh;overflow:auto;z-index:20;
  }
  .shop-row{display:flex;justify-content:space-between;align-items:center;padding:8px 4px;border-bottom:1px solid rgba(255,255,255,0.03)}
  .btn{background:linear-gradient(#0b72a1,#065a85);color:white;border:none;padding:8px 10px;border-radius:6px;cursor:pointer;font-weight:700}
  .muted{color:#9aa7b2;font-size:13px}
  @media (max-width:900px){ #shopModal{width:94vw;padding:12px} }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="canvas"></canvas>

  <div id="ui">
    <div id="timer">Time: 05:00</div>
    <div class="small" id="meta">Pts: 0 · Coins: 0 · Runs: 0</div>
  </div>

  <div id="shopModal" role="dialog" aria-hidden="true">
    <h2>Shop — Permanent Purchases</h2>
    <div id="shopContent"></div>
    <div style="margin-top:12px;text-align:right">
      <button id="shopClose" class="btn">Respawn (Start Run)</button>
    </div>
  </div>
</div>

<script>
/* TimeRunner — Full single-file build
   - Uses sprites in same folder:
     idleright.png, idleleft.png,
     jumpwalk1.png, jumpwalk1left.png,
     jump2.png, jump2left.png,
     jump3.png, jump3left.png
   - Player centered; worldX tracked separately
   - Chunk-based terrain generation
   - Cyclops targeting + beam
   - Reduced enemy hit penalty, higher jump
   - Shop after death, coins persisted in localStorage
*/

// ======= Canvas setup =======
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
window.addEventListener('resize', resize);
resize();

// ======= Config =======
const SAMPLE_W = 28;            // width of a terrain sample
const CHUNK_SAMPLES = 120;      // samples per chunk
const CHUNK_PX = SAMPLE_W * CHUNK_SAMPLES;
const GENERATE_AHEAD = 1500;    // px ahead of player's worldX to generate to
const KEEP_BEHIND = 900;        // px behind to keep
const GRAVITY = 0.9;
const JUMP_V = -18;             // higher jump
const BASE_TIME = 5 * 60;       // seconds per run
const PACE_MAX_SECONDS = 20;    // ensure mobs spawn if too quiet
const CYCL_TRACK_MS = 1200;
const CYCL_LOCK_MS = 500;
const CYCL_COOLDOWN_MS = 2400;
const FIXED_STEP = 16;          // ms fixed physics step

// ======= Save / persistence =======
const SAVE_KEY = 'timerunner_save_v1';
let save = loadSave();
function loadSave(){
  try{
    const raw = localStorage.getItem(SAVE_KEY);
    if(raw){
      const parsed = JSON.parse(raw);
      parsed.permWeapons = parsed.permWeapons || [];
      parsed.unlockedDungeonWeapons = parsed.unlockedDungeonWeapons || [];
      parsed.coins = parsed.coins || 0;
      parsed.permSpeed = parsed.permSpeed || 0;
      parsed.runs = parsed.runs || 0;
      parsed.equipped = parsed.equipped || 'Stick';
      parsed.timePenaltyReduction = parsed.timePenaltyReduction || 0;
      return parsed;
    }
  }catch(e){ console.warn('loadSave', e); }
  return { permWeapons:[], unlockedDungeonWeapons:[], coins:0, permSpeed:0, runs:0, equipped:'Stick', timePenaltyReduction:0, hasMagnet:false };
}
function saveToStorage(){ localStorage.setItem(SAVE_KEY, JSON.stringify(save)); updateUI(); }

// ======= Sprites: load (safe fallback) =======
const SPRITE_FILES = {
  idleright: 'idleright.png',
  idleleft: 'idleleft.png',
  jumpwalk1: 'jumpwalk1.png',
  jumpwalk1left: 'jumpwalk1left.png',
  jump2: 'jump2.png',
  jump2left: 'jump2left.png',
  jump3: 'jump3.png',
  jump3left: 'jump3left.png'
};
const SPRITES = {};
for(const k in SPRITE_FILES){
  const img = new Image();
  img.src = SPRITE_FILES[k];
  img.onload = ()=>{ SPRITES[k] = img; };
  img.onerror = ()=>{ SPRITES[k] = null; };
}

// ======= Game state =======
let world = {
  // terrainSamples maps sample index -> y
  samples: new Map(),
  minIndex: 0,
  maxIndex: -1,
  generatedMaxIndex: -1,
  chunks: []
};
let enemies = [];    // enemies with worldX, type, hp, etc.
let cyclopses = [];
let projectiles = [];
let items = [];      // pickups: {type:'money'|'dungeon-weapon', name?, worldX, y}
let dungeons = [];

let points = 0;
let timer = BASE_TIME;
let runActive = false;
let lastEncounterTime = performance.now();

// ======= Player =======
const PLAYER = {
  screenX: null,           // will set to canvas.width/2 in init
  worldX: 0,               // player's position in world coordinates
  y: 0,                    // screen Y (we'll control vertical by world terrain)
  vy: 0,
  w: 40, h: 56,
  speed: 4.0,
  facing: 'right',
  state: 'idle',
  animTimer: 0, animFrame: 0,
  equipped: save.equipped || 'Stick'
};

// ======= Input =======
const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if([" ","arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"].includes(e.key.toLowerCase())) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// ======= Enemy & weapon defs =======
// Reduced time penalties (weaker mobs)
const ENEMY_DEFS = {
  Slime: {w:32,h:20,color:'#4cd77a', hp:6, speed:0.9, timePenalty:3, reward:10},
  Goblin: {w:34,h:28,color:'#7ad97a', hp:12, speed:1.5, timePenalty:4, reward:18},
  Scorpion: {w:34,h:22,color:'#c38b3c', hp:10, speed:1.4, timePenalty:4, reward:16},
  Wolf: {w:36,h:24,color:'#8fb4ff', hp:14, speed:2.1, timePenalty:5, reward:22}
};

const WEAPONS = {
  'Stick': {dmg:4, range:36, cd:14, projectile:false},
  'Dagger': {dmg:7, range:36, cd:10, projectile:false},
  'Sword': {dmg:13, range:56, cd:18, projectile:false},
  'Bow': {dmg:10, range:320, cd:22, projectile:true, speed:11},
  'Staff': {dmg:14, range:360, cd:26, projectile:true, speed:9},
  'Laser Wand': {dmg:18, range:700, cd:28, projectile:true, speed:16}
};

// ======= Utility helpers =======
function rand(a,b){ return Math.random()*(b-a)+a; }
function rint(a,b){ return Math.floor(rand(a,b+1)); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function fmtTime(s){ const m=Math.floor(s/60), sec=Math.floor(s%60); return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`; }

// ======= Terrain generation (chunk-based) =======
const BIOMES = ['grass','desert','snow','mountain'];
function ensureTerrainForWorldX(worldX){
  const needIndex = Math.floor((worldX + GENERATE_AHEAD) / SAMPLE_W);
  while(world.generatedMaxIndex < needIndex){
    generateChunk(world.generatedMaxIndex + 1);
  }
  // cleanup behind to save memory
  const minKeepIndex = Math.floor((world.minIndex) || (Math.floor((world.generatedMaxIndex - Math.floor(KEEP_BEHIND / SAMPLE_W)) ));
  // remove older samples if needed (we'll keep map keys >= (playerIndex-keep))
  const keepFrom = Math.floor((PLAYER.worldX - KEEP_BEHIND) / SAMPLE_W);
  for(const key of Array.from(world.samples.keys())){
    if(key < keepFrom) { world.samples.delete(key); }
  }
}

function generateChunk(startIndex){
  // startIndex is sample index (not px). We'll generate CHUNK_SAMPLES samples starting at startIndex
  const biome = BIOMES[rint(0, BIOMES.length-1)];
  const baseY = (biome==='grass') ? canvas.height - 120 : (biome==='desert') ? canvas.height - 140 : (biome==='snow') ? canvas.height - 180 : canvas.height - 260;
  for(let i = 0; i < CHUNK_SAMPLES; i++){
    const idx = startIndex + i;
    const worldX = idx * SAMPLE_W;
    let noise = 0;
    if(biome==='grass') noise = Math.sin(worldX/130)*16 + rand(-6,6);
    else if(biome==='desert') noise = Math.sin(worldX/200)*10 + rand(-6,6);
    else if(biome==='snow') noise = Math.sin(worldX/90)*28 + rand(-10,10);
    else noise = Math.sin(worldX/70)*80 + rand(-18,18); // mountain
    const y = clamp(Math.round(baseY + noise), 80, canvas.height - 80);
    world.samples.set(idx, y);
    world.maxIndex = Math.max(world.maxIndex, idx);
    world.generatedMaxIndex = Math.max(world.generatedMaxIndex, idx);
    // occasionally spawn dungeons within chunk
    if(Math.random() < 0.012 && i > 6){
      const dx = worldX + rint(40, SAMPLE_W*4);
      dungeons.push({worldX: dx, y: (y - 80), w: 80, h: 80, weapon: chooseDungeonWeapon()});
      items.push({type:'dungeon-weapon', name:dungeons[dungeons.length-1].weapon, worldX: dx, y: y-28, claimed:false});
      if(Math.random() < 0.22) spawnCyclops(dx + rint(-60,60), y - rint(20,80));
    }
    // spawn occasional enemies
    if(Math.random() < 0.03){
      const ex = worldX + rint(0, SAMPLE_W-4);
      const ey = y - 12;
      spawnEnemyAt(ex, ey, chooseEnemyForBiome(biome));
    }
    // platforms in mountain
    if(biome === 'mountain' && Math.random() < 0.06 && i % 6 === 0){
      const pw = rint(80,160), pxpos = worldX + rint(-20,20), pypos = y - rint(120,260);
      // store as item to render as platform
      items.push({type:'platform', x:pxpos, y:pypos, w:pw});
    }
  }
  world.chunks.push({startIndex: startIndex, biome});
}

// pick dungeon weapon
function chooseDungeonWeapon(){ const pool = ['Dagger','Sword','Bow','Staff','Laser Wand','Bow','Sword','Dagger']; return pool[rint(0,pool.length-1)]; }
function chooseEnemyForBiome(b){
  if(b==='grass') return Math.random() < 0.5 ? 'Slime' : 'Goblin';
  if(b==='desert') return Math.random() < 0.6 ? 'Scorpion' : 'Goblin';
  if(b==='snow') return Math.random() < 0.6 ? 'Slime' : 'Wolf';
  if(b==='mountain') return Math.random() < 0.6 ? 'Wolf' : 'Slime';
  return 'Slime';
}

// ======= Entities management =======
function spawnEnemyAt(worldX, worldY, type){
  // avoid overlapping spawn
  for(const e of enemies){ if(Math.abs(e.worldX - worldX) < 40 && Math.abs(e.y - worldY) < 20) return; }
  const def = ENEMY_DEFS[type] || ENEMY_DEFS.Slime;
  enemies.push({worldX, y: worldY, type, w:def.w, h:def.h, hp:def.hp, color:def.color, speed:def.speed, timePenalty:def.timePenalty, reward:def.reward, id:Date.now() + '_' + Math.random()});
}
function spawnEnemy(type, baseY){
  // helper to spawn ahead near player
  const ex = PLAYER.worldX + rint(200, 520);
  spawnEnemyAt(ex, baseY, type || 'Slime');
}
function spawnCyclops(worldX, y){
  cyclopses.push({worldX, y, hp:36, state:'idle', stateStart: performance.now(), target:null, lastFired:0, id:'cycl_'+Date.now()+'_'+Math.random()});
}

// ======= Player attack & projectiles =======
let attackCooldown = 0;
function playerAttack(){
  const w = WEAPONS[PLAYER.equipped] || WEAPONS['Stick'];
  if(attackCooldown > 0) return;
  attackCooldown = w.cd;
  const dir = (PLAYER.facing === 'left') ? -1 : 1;
  if(w.projectile){
    projectiles.push({x: PLAYER.worldX + dir*36, y: PLAYER.y - 8, vx: dir * (w.speed || 10), vy: 0, dmg: w.dmg, life: w.range});
  } else {
    const r = w.range;
    const minX = PLAYER.worldX + (dir>0 ? 0 : -r), maxX = PLAYER.worldX + (dir>0 ? r : 0);
    enemies.slice().forEach(e => {
      if(e.worldX >= minX && e.worldX <= maxX && Math.abs(e.y - PLAYER.y) < 60){
        e.hp -= (w.dmg + rint(-2,2));
        if(e.hp <= 0) killEnemy(e);
      }
    });
    cyclopses.slice().forEach(c => {
      const d = Math.hypot(c.worldX - PLAYER.worldX, c.y - PLAYER.y);
      if(d < r/10 + 48){ c.hp -= (w.dmg + rint(-2,2)); if(c.hp <= 0) killCyclops(c); }
    });
  }
}
function updateProjectiles(dt){
  projectiles.slice().forEach(p => {
    p.x += p.vx * (dt/16);
    p.y += p.vy * (dt/16);
    p.life -= Math.abs(p.vx) * (dt/16);
    enemies.slice().forEach(e => {
      if(Math.abs(p.x - e.worldX) < e.w/2 + 8 && Math.abs(p.y - e.y) < e.h/2 + 8){
        e.hp -= p.dmg; projectiles = projectiles.filter(pp => pp !== p);
        if(e.hp <= 0) killEnemy(e);
      }
    });
    cyclopses.slice().forEach(c => {
      if(Math.abs(p.x - c.worldX) < 36 && Math.abs(p.y - c.y) < 36){
        c.hp -= p.dmg; projectiles = projectiles.filter(pp => pp !== p);
        if(c.hp <= 0) killCyclops(c);
      }
    });
    if(p.life <= 0) projectiles = projectiles.filter(pp => pp !== p);
  });
}
function killEnemy(e){
  enemies = enemies.filter(x => x !== e);
  points += e.reward || 20;
  save.coins += Math.max(3, Math.floor((e.reward || 12) / 2));
  if(Math.random() < 0.12) items.push({type:'money', amount: rint(6,40), worldX: e.worldX, y: e.y});
  if(Math.random() < 0.06) items.push({type:'dungeon-weapon', name: chooseDungeonWeapon(), worldX: Math.floor(e.worldX), y: e.y, claimed:false});
  if(Math.random() < 0.22) timer = Math.min(timer + 1, BASE_TIME);
  lastEncounterTime = performance.now();
  saveToStorage();
}
function killCyclops(c){
  cyclopses = cyclopses.filter(x => x !== c);
  items.push({type:'dungeon-weapon', name:'Laser Wand', worldX: Math.floor(c.worldX), y: c.y - 10, claimed:false});
  save.coins += 80; points += 240; lastEncounterTime = performance.now();
  saveToStorage();
}

// ======= Cyclops AI & beam =======
function updateCyclopses(dt){
  const now = performance.now();
  cyclopses.slice().forEach(c => {
    const dist = Math.hypot(PLAYER.worldX - c.worldX, PLAYER.y - c.y);
    if(c.state === 'idle'){
      if(dist < 1400) c.worldX += (PLAYER.worldX > c.worldX ? 0.12 : -0.12) * (dt/16);
      if(dist < 640 && Math.random() < 0.006) { c.state = 'track'; c.stateStart = now; c.target = {x: PLAYER.worldX, y: PLAYER.y}; }
    } else if(c.state === 'track'){
      c.target = {x: PLAYER.worldX, y: PLAYER.y};
      if(now - c.stateStart >= CYCL_TRACK_MS) { c.state = 'lock'; c.stateStart = now; }
    } else if(c.state === 'lock'){
      if(now - c.stateStart >= CYCL_LOCK_MS){
        fireCyclopsBeam(c, c.target || {x:PLAYER.worldX, y:PLAYER.y});
        c.lastFired = now; c.state = 'cooldown'; c.stateStart = now;
      }
    } else if(c.state === 'cooldown'){
      if(now - c.stateStart >= CYCL_COOLDOWN_MS) c.state = 'idle';
    }
  });
}
function fireCyclopsBeam(c, target){
  // beam from c.worldX to infinite in that direction. If player is near line -> apply time penalty
  const sx = c.worldX, sy = c.y - 4;
  const tx = target.x, ty = target.y - 8;
  const ang = Math.atan2(ty - sy, tx - sx);
  const length = Math.max(canvas.width, canvas.height) * 2;
  const ex = sx + Math.cos(ang) * length, ey = sy + Math.sin(ang) * length;
  const d = pointToLineDistance(PLAYER.worldX, PLAYER.y, sx, sy, ex, ey);
  if(d < 18){
    const reduction = save.timePenaltyReduction || 0;
    const penalty = Math.max(6, Math.round(12 * (1 - reduction)));
    timer = Math.max(0, timer - penalty);
    lastEncounterTime = performance.now();
  }
  // beam damages nearby enemies
  enemies.slice().forEach(e => {
    const de = pointToLineDistance(e.worldX, e.y, sx, sy, ex, ey);
    if(de < 22){ e.hp -= 18; if(e.hp <= 0) killEnemy(e); }
  });
}

// geometry helper
function pointToLineDistance(px,py,x1,y1,x2,y2){
  const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
  const dot = A*C + B*D;
  const len_sq = C*C + D*D;
  let param = -1;
  if(len_sq !== 0) param = dot / len_sq;
  let xx, yy;
  if(param < 0){ xx = x1; yy = y1; }
  else if(param > 1){ xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  const dx = px - xx, dy = py - yy; return Math.hypot(dx,dy);
}

// ======= Pacing =======
function ensurePacing(){
  if((performance.now() - lastEncounterTime) > (PACE_MAX_SECONDS * 1000)){
    const count = rint(2,4);
    for(let i=0;i<count;i++){
      const ex = PLAYER.worldX + rint(220, 520);
      spawnEnemyAt(ex, sampleTerrainY(ex) - 12, chooseEnemyForBiome(getBiomeAtWorldX(ex)));
    }
    if(Math.random() < 0.45) spawnCyclops(PLAYER.worldX + rint(300,720), sampleTerrainY(PLAYER.worldX + 600) - rint(0,80));
    lastEncounterTime = performance.now();
  }
  let near = enemies.filter(e => Math.abs(e.worldX - PLAYER.worldX) < 500).length;
  if(near < 4){
    for(let i=0;i<4-near;i++){
      const ex = PLAYER.worldX + rint(220, 520);
      spawnEnemyAt(ex, sampleTerrainY(ex) - 12, chooseEnemyForBiome(getBiomeAtWorldX(ex)));
    }
  }
  if(enemies.length > 250) enemies = enemies.slice(0,250);
}

// ======= terrain sampling =======
function sampleTerrainY(worldX){
  const idx = Math.floor(worldX / SAMPLE_W);
  if(world.samples.has(idx)) return world.samples.get(idx);
  // if not generated yet, fallback to default baseline
  return canvas.height - 140;
}
function getBiomeAtWorldX(worldX){
  // find chunk containing index
  const idx = Math.floor(worldX / SAMPLE_W);
  for(const ch of world.chunks){
    if(idx >= ch.startIndex && idx < ch.startIndex + CHUNK_SAMPLES) return ch.biome;
  }
  return 'grass';
}

// ======= Timers / run control =======
let accumulator = 0;
let lastRAF = performance.now();
let timerTickHandle = null;

function startRun(){
  // initialize world & player, clear entities
  world.samples.clear(); world.chunks.length = 0; world.generatedMaxIndex = -1; world.maxIndex = -1; world.minIndex = 0;
  enemies.length = 0; cyclopses.length = 0; projectiles.length = 0; items.length = 0; dungeons.length = 0;
  points = 0; timer = BASE_TIME; runActive = true; lastEncounterTime = performance.now();

  PLAYER.worldX = 400; // start point in world
  PLAYER.screenX = Math.floor(canvas.width / 2);
  PLAYER.y = sampleTerrainY(PLAYER.worldX) - PLAYER.h/2 + 8;
  PLAYER.vy = 0;
  PLAYER.equipped = save.equipped || 'Stick';
  save.runs = save.runs || 0;
  saveToStorage();

  // pre-generate a bit
  ensureTerrainForWorldX(PLAYER.worldX);
  startTimerTick();
  lastRAF = performance.now();
  requestAnimationFrame(raf);
}

function endRun(){
  runActive = false;
  if(timerTickHandle) clearInterval(timerTickHandle);
  save.runs = (save.runs || 0) + 1;
  saveToStorage();
  openShop();
}

function startTimerTick(){
  if(timerTickHandle) clearInterval(timerTickHandle);
  timerTickHandle = setInterval(() => {
    if(runActive) {
      timer = Math.max(0, timer - 1);
      updateUI();
      if(timer <= 0) endRun();
    }
  }, 1000);
}

// ======= Input actions binding =======
window.addEventListener('keydown', (e) => {
  if(e.key === ' '){ // space = attack
    e.preventDefault();
    playerAttack();
  }
});

// ======= Fixed-step loop (stable physics) =======
function raf(now){
  const dt = now - lastRAF;
  lastRAF = now;
  accumulator += dt;
  // cap accumulator to avoid spiral-of-death
  if(accumulator > 200) accumulator = 200;
  while(accumulator >= FIXED_STEP){
    fixedUpdate(FIXED_STEP);
    accumulator -= FIXED_STEP;
  }
  render();
  if(runActive) requestAnimationFrame(raf);
}

let attackCooldown = 0;
function fixedUpdate(dt){
  if(!runActive) return;
  // handle input: move world relative to player
  let moving = false;
  const speedFactor = 1 + (save.permSpeed || 0);
  if(keys['a'] || keys['arrowleft']){ PLAYER.worldX -= PLAYER.speed * speedFactor * (dt/16); PLAYER.facing = 'left'; moving = true; }
  if(keys['d'] || keys['arrowright']){ PLAYER.worldX += PLAYER.speed * speedFactor * (dt/16); PLAYER.facing = 'right'; moving = true; }

  // jumping
  if((keys['w'] || keys['arrowup'] || keys[' ']) && PLAYER.vy === 0){
    // Only initiate on initial press; basic edge detection by seeing vy === 0 and grounded via terrain
    PLAYER.vy = JUMP_V;
  }
  // gravity & vertical move
  PLAYER.vy += GRAVITY * (dt/16);
  PLAYER.y += PLAYER.vy * (dt/16);

  // ground collision: sample at player's worldX
  const groundY = sampleTerrainY(PLAYER.worldX);
  const targetY = groundY - PLAYER.h/2 + 8;
  if(PLAYER.y > targetY){
    PLAYER.y = targetY;
    PLAYER.vy = 0;
  }

  // animation state
  if(PLAYER.vy !== 0) PLAYER.state = 'jump';
  else if(moving) PLAYER.state = 'walk';
  else PLAYER.state = 'idle';
  PLAYER.animTimer += dt;
  if(PLAYER.animTimer > 110) { PLAYER.animTimer = 0; PLAYER.animFrame = (PLAYER.animFrame + 1) % 3; }

  // update projectiles & cooldown
  if(attackCooldown > 0) attackCooldown = Math.max(0, attackCooldown - (dt/16));
  updateProjectiles(dt);

  // update enemies: basic chase behavior
  for(const e of enemies){
    const dx = PLAYER.worldX - e.worldX;
    if(Math.abs(dx) < 700) e.worldX += Math.sign(dx) * e.speed * (dt/16);
    else e.worldX += (Math.random()-0.5) * 0.25;
    // vertical correct to terrain
    e.y = sampleTerrainY(e.worldX) - 10;
    // collision with player
    if(Math.abs(e.worldX - PLAYER.worldX) < 28 && Math.abs(e.y - PLAYER.y) < 40){
      applyHitPenalty(e.timePenalty || 4);
      // push enemy away to avoid multiple hits instantly
      e.worldX += (e.worldX < PLAYER.worldX ? -16 : 16);
      lastEncounterTime = performance.now();
    }
  }

  // cyclops updates
  updateCyclopses(dt);

  // items pickup
  items.slice().forEach(it => {
    if(Math.abs(it.worldX - PLAYER.worldX) < 28 && Math.abs((it.y || sampleTerrainY(it.worldX)) - PLAYER.y) < 36){
      if(it.type === 'money'){ save.coins += it.amount; points += it.amount; }
      else if(it.type === 'dungeon-weapon' && !it.claimed){ it.claimed = true; if(!save.unlockedDungeonWeapons.includes(it.name)) save.unlockedDungeonWeapons.push(it.name); points += 30; }
      items = items.filter(x => x !== it);
      saveToStorage();
    }
  });

  // ensure terrain generated and pacing
  ensureTerrainForWorldX(PLAYER.worldX);
  if(Math.random() < 0.002) ensurePacing();

  // cap heavy arrays if necessary
  if(enemies.length > 300) enemies = enemies.slice(0,300);
}

// ======= Hit penalty application =======
function applyHitPenalty(secs){
  const reduction = save.timePenaltyReduction || 0;
  const pen = Math.max(2, Math.round(secs * (1 - reduction)));
  timer = Math.max(0, timer - pen);
  lastEncounterTime = performance.now();
}

// ======= Rendering =======
function render(){
  // clear background
  ctx.fillStyle = '#6eaedb'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // parallax background band
  ctx.fillStyle = '#0b2a3a'; ctx.fillRect(0, canvas.height - 300, canvas.width, 300);

  // camera left edge worldX
  const camLeftWorldX = PLAYER.worldX - PLAYER.screenX;

  // draw terrain samples in visible region
  const startIdx = Math.floor((camLeftWorldX - 200) / SAMPLE_W);
  const endIdx = Math.ceil((camLeftWorldX + canvas.width + 200) / SAMPLE_W);
  for(let idx = startIdx; idx <= endIdx; idx++){
    const y = world.samples.has(idx) ? world.samples.get(idx) : (canvas.height - 140);
    const sx = (idx * SAMPLE_W) - camLeftWorldX;
    const biome = getBiomeAtWorldX(idx * SAMPLE_W);
    let color = (biome === 'desert') ? '#C9B17A' : (biome === 'snow') ? '#DFF6FF' : (biome === 'mountain') ? '#9EA3A8' : '#2b6b3a';
    ctx.fillStyle = color;
    ctx.fillRect(sx, y, SAMPLE_W + 1, canvas.height - y);
  }

  // draw dungeons
  dungeons.forEach(d => {
    const sx = d.worldX - camLeftWorldX;
    if(sx < -200 || sx > canvas.width + 200) return;
    ctx.fillStyle = '#B05400'; ctx.fillRect(sx - 12, d.y - 40, 64, 40);
    ctx.fillStyle = '#351E12'; ctx.fillRect(sx - 12, d.y - 40, 64, 8);
  });

  // draw items (pickups & platforms)
  items.forEach(it => {
    const sx = it.worldX - camLeftWorldX;
    if(sx < -200 || sx > canvas.width + 200) return;
    if(it.type === 'money'){ ctx.fillStyle = '#ffd86b'; ctx.fillRect(sx - 6, (it.y || sampleTerrainY(it.worldX)) - 18, 12, 12); }
    else if(it.type === 'dungeon-weapon'){ ctx.fillStyle = '#ffd86b'; ctx.fillRect(sx - 8, (it.y || sampleTerrainY(it.worldX)) - 22, 16, 14); ctx.fillStyle = '#000'; ctx.fillText('W', sx - 2, (it.y || sampleTerrainY(it.worldX)) - 10); }
    else if(it.type === 'platform'){ ctx.fillStyle = '#7b5a3a'; ctx.fillRect(sx, it.y, it.w, 10); }
  });

  // draw enemies
  enemies.forEach(e => {
    const sx = e.worldX - camLeftWorldX;
    if(sx < -200 || sx > canvas.width + 200) return;
    ctx.fillStyle = e.color || '#c94b4b';
    ctx.fillRect(sx - e.w/2, e.y - e.h, e.w, e.h);
    // hp bar
    ctx.fillStyle = '#000'; ctx.fillRect(sx - e.w/2, e.y - e.h - 8, e.w, 5);
    ctx.fillStyle = '#ff6b6b'; ctx.fillRect(sx - e.w/2, e.y - e.h - 8, e.w * clamp(e.hp / (ENEMY_DEFS[e.type]?.hp || 16), 0, 1), 5);
  });

  // draw cyclops (with tracking line if applicable)
  cyclopses.forEach(c => {
    const sx = c.worldX - camLeftWorldX;
    if(sx < -400 || sx > canvas.width + 400) return;
    const sy = c.y - 24;
    ctx.fillStyle = '#9a8f8f'; ctx.fillRect(sx - 22, sy - 18, 44, 44);
    ctx.fillStyle = '#ffefef'; ctx.fillRect(sx - 6, sy - 8, 12, 12);
    if(c.state === 'track' && c.target){
      ctx.strokeStyle = 'rgba(255,120,120,0.95)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo((c.target.x - camLeftWorldX), c.target.y - 8); ctx.stroke();
    } else if(c.state === 'lock' && c.target){
      ctx.strokeStyle = 'rgba(255,40,40,1)'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo((c.target.x - camLeftWorldX), c.target.y - 8); ctx.stroke();
    } else if(c.lastFired && performance.now() - c.lastFired < 400){
      const sxReal = sx, syReal = sy;
      const tx = (c.target ? (c.target.x - camLeftWorldX) : (PLAYER.screenX));
      const ty = (c.target ? (c.target.y - 8) : (PLAYER.y - 8));
      ctx.strokeStyle = 'rgba(255,20,20,0.95)'; ctx.lineWidth = 8;
      ctx.beginPath(); ctx.moveTo(sxReal, syReal); ctx.lineTo(tx + (tx - sxReal)*6, ty + (ty - syReal)*6); ctx.stroke();
    }
  });

  // draw projectiles
  projectiles.forEach(p => {
    const sx = p.x - camLeftWorldX;
    if(sx < -200 || sx > canvas.width + 200) return;
    ctx.fillStyle = '#fff'; ctx.fillRect(sx - 3, p.y - 3, 6, 6);
  });

  // draw player at center
  const screenX = PLAYER.screenX;
  const screenY = PLAYER.y - PLAYER.h/2 + 8;
  let spriteKey = 'idleright';
  if(PLAYER.state === 'idle') spriteKey = (PLAYER.facing === 'right') ? 'idleright' : 'idleleft';
  else if(PLAYER.state === 'walk') {
    const frame = PLAYER.animFrame % 2;
    spriteKey = (frame === 1) ? ((PLAYER.facing === 'right') ? 'jumpwalk1' : 'jumpwalk1left') : ((PLAYER.facing === 'right') ? 'idleright' : 'idleleft');
  } else if(PLAYER.state === 'jump') {
    const frame = PLAYER.animFrame % 3;
    spriteKey = (frame === 1) ? ((PLAYER.facing === 'right') ? 'jump2' : 'jump2left') : ((PLAYER.facing === 'right') ? 'jump3' : 'jump3left');
  }
  const img = SPRITES[spriteKey];
  if(img && img.complete){
    ctx.drawImage(img, screenX - PLAYER.w/2, screenY - PLAYER.h/2, PLAYER.w, PLAYER.h);
  } else {
    ctx.fillStyle = '#7dd3fc'; ctx.fillRect(screenX - PLAYER.w/2, screenY - PLAYER.h/2, PLAYER.w, PLAYER.h);
  }

  // HUD
  ctx.fillStyle = '#000'; ctx.globalAlpha = 0.55; ctx.fillRect(10,10,260,56); ctx.globalAlpha = 1;
  ctx.fillStyle = '#fff'; ctx.font = '18px monospace'; ctx.fillText('Time: ' + fmtTime(timer), 18, 32);
  ctx.font = '12px monospace'; ctx.fillText('Pts: ' + Math.floor(points) + '  Coins: ' + save.coins + '  Runs: ' + (save.runs || 0), 18, 52);
}

// ======= Shop UI =======
const shopModal = document.getElementById('shopModal');
const shopContent = document.getElementById('shopContent');
const shopClose = document.getElementById('shopClose');
shopClose.addEventListener('click', () => { shopModal.style.display = 'none'; startRun(); });

function openShop(){
  shopContent.innerHTML = '';
  const header = document.createElement('div');
  header.className = 'muted';
  header.style.marginBottom = '8px';
  header.innerHTML = `Run ended — Points: <strong>${Math.floor(points)}</strong>`;
  shopContent.appendChild(header);

  // Weapons found
  const wTitle = document.createElement('div'); wTitle.innerHTML = '<strong>Weapons (found)</strong>'; wTitle.style.marginTop = '8px';
  shopContent.appendChild(wTitle);
  const weaponsList = document.createElement('div');
  weaponsList.style.marginBottom = '8px';
  if((save.unlockedDungeonWeapons || []).length === 0){
    const p = document.createElement('div'); p.className = 'muted'; p.textContent = 'No weapons discovered yet.'; weaponsList.appendChild(p);
  } else {
    save.unlockedDungeonWeapons.forEach(w => {
      const row = document.createElement('div'); row.className = 'shop-row';
      row.innerHTML = `<div style="font-weight:700">${w}</div><div><strong>150</strong> <button class="btn buyW" data-w="${w}">Buy</button></div>`;
      weaponsList.appendChild(row);
    });
  }
  shopContent.appendChild(weaponsList);

  // Upgrades
  const upTitle = document.createElement('div'); upTitle.innerHTML = '<strong>Upgrades</strong>'; shopContent.appendChild(upTitle);
  const upList = document.createElement('div');
  upList.style.marginBottom = '8px';
  const upSpeed = document.createElement('div'); upSpeed.className = 'shop-row'; upSpeed.innerHTML = `<div>+0.5 Speed</div><div><strong>100</strong> <button id="buySpeed" class="btn">Buy</button></div>`;
  const upPenalty = document.createElement('div'); upPenalty.className = 'shop-row'; upPenalty.innerHTML = `<div>Reduce hit penalty (5%)</div><div><strong>120</strong> <button id="buyPenalty" class="btn">Buy</button></div>`;
  const upTime = document.createElement('div'); upTime.className = 'shop-row'; upTime.innerHTML = `<div>+15s Starting Time</div><div><strong>140</strong> <button id="buyTime" class="btn">Buy</button></div>`;
  upList.appendChild(upSpeed); upList.appendChild(upPenalty); upList.appendChild(upTime);
  shopContent.appendChild(upList);

  // Utilities
  const utilTitle = document.createElement('div'); utilTitle.innerHTML = '<strong>Utilities</strong>'; shopContent.appendChild(utilTitle);
  const utilList = document.createElement('div'); utilList.style.marginBottom = '8px';
  const magnet = document.createElement('div'); magnet.className = 'shop-row'; magnet.innerHTML = `<div>Coin Magnet (start-of-run)</div><div><strong>200</strong> <button id="buyMagnet" class="btn">Buy</button></div>`;
  utilList.appendChild(magnet);
  shopContent.appendChild(utilList);

  // wire actions
  shopContent.querySelectorAll('.buyW').forEach(b => {
    b.addEventListener('click', () => {
      const w = b.dataset.w;
      if(save.coins >= 150){ save.coins -= 150; if(!save.permWeapons.includes(w)) save.permWeapons.push(w); save.equipped = w; saveToStorage(); openShop(); }
      else alert('Not enough coins');
    });
  });
  shopContent.querySelector('#buySpeed')?.addEventListener('click', () => {
    if(save.coins >= 100){ save.coins -= 100; save.permSpeed = (save.permSpeed || 0) + 0.5; saveToStorage(); openShop(); } else alert('Not enough coins');
  });
  shopContent.querySelector('#buyPenalty')?.addEventListener('click', () => {
    if(save.coins >= 120){ save.coins -= 120; save.timePenaltyReduction = (save.timePenaltyReduction || 0) + 0.05; saveToStorage(); openShop(); } else alert('Not enough coins');
  });
  shopContent.querySelector('#buyTime')?.addEventListener('click', () => {
    if(save.coins >= 140){ save.coins -= 140; // increase BASE_TIME for this session persistently
      // store extra time as permanent startingTimeBoost in save
      save.startTimeBoost = (save.startTimeBoost || 0) + 15; saveToStorage(); openShop(); } else alert('Not enough coins');
  });
  shopContent.querySelector('#buyMagnet')?.addEventListener('click', () => {
    if(save.coins >= 200){ save.coins -= 200; save.hasMagnet = true; saveToStorage(); openShop(); } else alert('Not enough coins');
  });

  shopModal.style.display = 'block';
  shopModal.setAttribute('aria-hidden','false');
}

// ======= helpers for UI =======
function updateUI(){
  document.getElementById('timer').textContent = 'Time: ' + fmtTime(timer);
  document.getElementById('meta').textContent = `Pts: ${Math.floor(points)} · Coins: ${save.coins} · Runs: ${save.runs || 0}`;
}

// ======= main loop bootstrap =======
function raf(now){
  const dt = now - lastRAF;
  lastRAF = now;
  accumulator += dt;
  if(accumulator > 200) accumulator = 200;
  while(accumulator >= FIXED_STEP){
    fixedUpdate(FIXED_STEP);
    accumulator -= FIXED_STEP;
  }
  render();
  if(runActive) requestAnimationFrame(raf);
}

// Attach one master RAF reference variable (avoid duplicate)
lastRAF = performance.now();
accumulator = 0;

// ======= Implement fixedUpdate (single source of truth) =======
function fixedUpdate(dt){
  if(!runActive) return;
  // movement input
  let moving = false;
  const speedFactor = 1 + (save.permSpeed || 0);
  if(keys['a'] || keys['arrowleft']){ PLAYER.worldX -= PLAYER.speed * speedFactor * (dt/16); PLAYER.facing = 'left'; moving = true; }
  if(keys['d'] || keys['arrowright']){ PLAYER.worldX += PLAYER.speed * speedFactor * (dt/16); PLAYER.facing = 'right'; moving = true; }

  // jump input (edge detection approximate: if vy==0 -> we consider on ground)
  if((keys['w'] || keys['arrowup'] || keys[' ']) && PLAYER.vy === 0){
    PLAYER.vy = JUMP_V;
  }
  // gravity & vertical
  PLAYER.vy += GRAVITY * (dt/16);
  PLAYER.y += PLAYER.vy * (dt/16);

  // ground collision by sampling terrain at player.worldX
  const ground = sampleTerrainY(PLAYER.worldX);
  const targetY = ground - PLAYER.h/2 + 8;
  if(PLAYER.y > targetY){
    PLAYER.y = targetY; PLAYER.vy = 0;
  }

  // anim state
  if(PLAYER.vy !== 0) PLAYER.state = 'jump';
  else if(moving) PLAYER.state = 'walk';
  else PLAYER.state = 'idle';
  PLAYER.animTimer += dt;
  if(PLAYER.animTimer > 110){ PLAYER.animTimer = 0; PLAYER.animFrame = (PLAYER.animFrame + 1) % 3; }

  // cooldown and projectiles
  if(attackCooldown > 0) attackCooldown = Math.max(0, attackCooldown - (dt/16));
  updateProjectiles(dt);

  // enemies update
  for(const e of enemies){
    const dx = PLAYER.worldX - e.worldX;
    if(Math.abs(dx) < 700) e.worldX += Math.sign(dx) * e.speed * (dt/16);
    else e.worldX += (Math.random() - 0.5) * 0.25;
    e.y = sampleTerrainY(e.worldX) - 10;
    if(Math.abs(e.worldX - PLAYER.worldX) < 28 && Math.abs(e.y - PLAYER.y) < 40){
      applyHitPenalty(e.timePenalty);
      e.worldX += (e.worldX < PLAYER.worldX ? -12 : 12);
      lastEncounterTime = performance.now();
    }
  }

  // cyclops
  updateCyclopses(dt);

  // item pickup handled
  for(const it of items.slice()){
    if(Math.abs(it.worldX - PLAYER.worldX) < 28 && Math.abs((it.y || sampleTerrainY(it.worldX)) - PLAYER.y) < 36){
      if(it.type === 'money'){ save.coins += it.amount; points += it.amount; }
      else if(it.type === 'dungeon-weapon' && !it.claimed){ it.claimed = true; if(!save.unlockedDungeonWeapons.includes(it.name)) save.unlockedDungeonWeapons.push(it.name); points += 30; }
      items = items.filter(x => x !== it);
      saveToStorage();
    }
  }

  // ensure generation + pacing
  ensureTerrainForWorldX(PLAYER.worldX);
  if(Math.random() < 0.002) ensurePacing();

  // decrease global timer per second handled by timerTick
}

// ======= Timer tick (1s) =======
let timerTick = null;
function startTimerTick(){
  if(timerTick) clearInterval(timerTick);
  timerTick = setInterval(() => {
    if(runActive){
      timer = Math.max(0, timer - 1);
      updateUI();
      if(timer <= 0) endRun();
    }
  }, 1000);
}

// ======= Apply hit penalty (time loss) =======
function applyHitPenalty(secs){
  const reduction = save.timePenaltyReduction || 0;
  const pen = Math.max(2, Math.round(secs * (1 - reduction)));
  timer = Math.max(0, timer - pen);
  lastEncounterTime = performance.now();
}

// ======= Ensure terrain wrapper (calls generator) =======
function ensureTerrainForWorldX(worldX){
  const needIndex = Math.floor((worldX + GENERATE_AHEAD) / SAMPLE_W);
  while(world.generatedMaxIndex < needIndex){
    generateChunk(world.generatedMaxIndex + 1);
  }
  // cleanup old samples behind
  const keepFrom = Math.floor((PLAYER.worldX - KEEP_BEHIND) / SAMPLE_W);
  for(const k of Array.from(world.samples.keys())){
    if(k < keepFrom) world.samples.delete(k);
  }
}

// ======= Rendering helper & main render wrapper set earlier =======
// render() already defined above

// ======= Game flow: start and end =======
function startGame(){
  // reset world and entities
  world.samples.clear(); world.chunks = []; world.generatedMaxIndex = -1; world.maxIndex = -1;
  enemies = []; cyclopses = []; projectiles = []; items = []; dungeons = [];
  points = 0; timer = BASE_TIME + (save.startTimeBoost || 0); runActive = true; lastEncounterTime = performance.now();
  PLAYER.worldX = 400; PLAYER.screenX = Math.floor(canvas.width / 2);
  PLAYER.y = sampleTerrainY(PLAYER.worldX) - PLAYER.h/2 + 8; PLAYER.vy = 0; PLAYER.equipped = save.equipped || 'Stick';
  save.runs = save.runs || 0; saveToStorage();
  ensureTerrainForWorldX(PLAYER.worldX);
  startTimerTick();
  lastRAF = performance.now();
  requestAnimationFrame(raf);
}
function endRun(){
  runActive = false;
  if(timerTick) clearInterval(timerTick);
  save.runs = (save.runs || 0) + 1; saveToStorage();
  openShop();
}

// ======= UI / Shop triggers =======
function openShop(){
  // pause everything
  shopModal.style.display = 'block';
  shopModal.setAttribute('aria-hidden','false');
  // fill content (function defined earlier)
  openShopContent();
}
function openShopContent(){
  openShop(); // we already use openShop as modal opener above; this small wrapper is harmless
}

// Avoid recursion above: implement proper shop fill function and call it:
function openShop(){
  shopContent.innerHTML = '';
  const info = document.createElement('div'); info.className='muted'; info.style.marginBottom = '8px';
  info.innerHTML = `Run ended — Points: <strong>${Math.floor(points)}</strong>`;
  shopContent.appendChild(info);

  // Weapons (found)
  const wtitle = document.createElement('div'); wtitle.innerHTML = '<strong>Weapons (found)</strong>'; shopContent.appendChild(wtitle);
  const wlist = document.createElement('div');
  if((save.unlockedDungeonWeapons || []).length === 0){
    const p = document.createElement('div'); p.className = 'muted'; p.textContent = 'No weapons discovered.'; wlist.appendChild(p);
  } else {
    save.unlockedDungeonWeapons.forEach(w => {
      const row = document.createElement('div'); row.className = 'shop-row';
      row.innerHTML = `<div style="font-weight:700">${w}</div><div><strong>150</strong> <button class="btn buyW" data-w="${w}">Buy</button></div>`;
      wlist.appendChild(row);
    });
  }
  shopContent.appendChild(wlist);

  // Upgrades
  const utitle = document.createElement('div'); utitle.innerHTML = '<strong>Upgrades</strong>'; utitle.style.marginTop = '8px'; shopContent.appendChild(utitle);
  const ulist = document.createElement('div');
  const s1 = document.createElement('div'); s1.className='shop-row'; s1.innerHTML = `<div>+0.5 Speed</div><div><strong>100</strong> <button id="buySpeed" class="btn">Buy</button></div>`;
  const s2 = document.createElement('div'); s2.className='shop-row'; s2.innerHTML = `<div>Reduce hit penalty (5%)</div><div><strong>120</strong> <button id="buyPenalty" class="btn">Buy</button></div>`;
  const s3 = document.createElement('div'); s3.className='shop-row'; s3.innerHTML = `<div>+15s Starting Time</div><div><strong>140</strong> <button id="buyTime" class="btn">Buy</button></div>`;
  ulist.appendChild(s1); ulist.appendChild(s2); ulist.appendChild(s3);
  shopContent.appendChild(ulist);

  // Utilities
  const utilTitle = document.createElement('div'); utilTitle.innerHTML = '<strong>Utilities</strong>'; utilTitle.style.marginTop = '8px'; shopContent.appendChild(utilTitle);
  const utilList = document.createElement('div'); const mrow = document.createElement('div'); mrow.className='shop-row'; mrow.innerHTML = `<div>Coin Magnet</div><div><strong>200</strong> <button id="buyMagnet" class="btn">Buy</button></div>`; utilList.appendChild(mrow);
  shopContent.appendChild(utilList);

  // wire actions
  shopContent.querySelectorAll('.buyW').forEach(b => {
    b.addEventListener('click', () => { const w = b.dataset.w; if(save.coins >= 150){ save.coins -= 150; if(!save.permWeapons.includes(w)) save.permWeapons.push(w); save.equipped = w; saveToStorage(); openShop(); } else alert('Not enough coins'); });
  });
  shopContent.querySelector('#buySpeed')?.addEventListener('click', () => { if(save.coins >= 100){ save.coins -= 100; save.permSpeed = (save.permSpeed || 0) + 0.5; saveToStorage(); openShop(); } else alert('Not enough coins'); });
  shopContent.querySelector('#buyPenalty')?.addEventListener('click', () => { if(save.coins >= 120){ save.coins -= 120; save.timePenaltyReduction = (save.timePenaltyReduction || 0) + 0.05; saveToStorage(); openShop(); } else alert('Not enough coins'); });
  shopContent.querySelector('#buyTime')?.addEventListener('click', () => { if(save.coins >= 140){ save.coins -= 140; save.startTimeBoost = (save.startTimeBoost || 0) + 15; saveToStorage(); openShop(); } else alert('Not enough coins'); });
  shopContent.querySelector('#buyMagnet')?.addEventListener('click', () => { if(save.coins >= 200){ save.coins -= 200; save.hasMagnet = true; saveToStorage(); openShop(); } else alert('Not enough coins'); });

  shopModal.style.display = 'block';
  shopModal.setAttribute('aria-hidden', 'false');
}

// ======= Begin game =======
updateUI();
startGame();

// Expose some useful debug helpers in window for testing
window._save = save;
window._start = startGame;
window._end = endRun;
window._export = () => { const data = JSON.stringify(save, null, 2); const blob = new Blob([data], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'timerunner_save.json'; a.click(); URL.revokeObjectURL(url); };

</script>
</body>
</html>
